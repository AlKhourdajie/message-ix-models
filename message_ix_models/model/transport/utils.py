from contextlib import contextmanager
from collections import ChainMap, defaultdict
from itertools import product
import logging.config
from pathlib import Path

import yaml
import pandas as pd
import xarray as xr


# Path to the directory containing data & metadata files
data_path = Path(__file__).resolve().parents[3] / 'data' / 'transport'


# Configuration dictionary
config = {}


def read_config():
    """Read the transport model configuration from file."""
    global config

    def yaml_data(*parts):
        """Open a YAML file in the (meta)data directory and return contents."""
        with open(data_path.joinpath(*parts).with_suffix('.yaml')) as f:
            return yaml.load(f)

    config = {
        # Storage for exogenous data
        'data': xr.Dataset(),

        # Information about the MESSAGE V model
        'MESSAGE V': {
            'set': yaml_data('migrate', 'set'),
            },

        # Information about the MESSAGEix framework
        'param': yaml_data('..', 'parameter'),

        # Information about MESSAGE-Transport
        'model': yaml_data('config'),
        'set': yaml_data('set'),
        'tech': yaml_data('technology'),
        }

    # Callback information
    cb_cfg = yaml_data('callback')

    # Convert files to xr.DataArrays
    for key, dims in cb_cfg.pop('files').items():
        config['data'][key] = xr.DataArray.from_series(
            pd.read_csv(data_path / f'{key}.csv', index_col=0)
            .rename_axis(dims[1], axis=1)
            .stack())

    # Convert scalar parameters
    for key, val in cb_cfg.pop('params').items():
        config['data'][key] = val

    # Configure logging
    with open(Path(__file__).parent / 'logging.yaml') as f:
        logging.config.dictConfig(yaml.load(f))


read_config()


def consumer_groups(with_desc=False):
    """Iterate over consumer groups in ``sets.yaml``."""
    dims = ['location', 'attitude', 'frequency']
    cfg = config['set']['consumer groups']

    # Assemble technology names
    keys = [cfg[d].keys() for d in dims]
    name = [''.join(k) for k in product(*keys)]

    if with_desc:
        # Assemble technology descriptions
        vals = [cfg[d].values() for d in dims]
        desc = [', '.join(v).lower() for v in product(*vals)]

        yield from sorted(zip(name, desc))
    else:
        yield from sorted(name)


def make_df(par_name, tech=None, **kwargs):
    """Return an empty dataframe for *par_name*, *tech*."""
    cols = config['param'][par_name] + ['value', 'unit']
    data = {}
    try:
        tec_info = config['tech']['technology'][tech]['par'][par_name]
        tec_info['technology'] = tech
    except KeyError:
        tec_info = {}

    data = ChainMap(kwargs, tec_info, defaultdict(lambda: None))
    data = {c: data[c] for c in cols}

    return pd.DataFrame.from_dict(data, orient='columns')


def iter_parameters(set_name):
    """Iterate over MESSAGEix parameters with *set_name* as a dimension."""
    for name, dims in config['param'].items():
        if set_name in dims:
            yield name


def transport_technologies(by_cg=True, filter=[], with_desc=False):
    """Iterate over transport technologies in ``messagev-tech.yaml``.

    Technologies listed with `by_consumer_group` = :obj:`True` are returned
    once for each consumer group generated by :meth:`consumer_groups`.
    """
    for tech, info in config['tech']['technology'].items():
        if len(filter) and tech not in filter:
            continue

        if by_cg and info.get('by_consumer_group', False):
            if with_desc:
                for name, desc in consumer_groups(with_desc=True):
                    yield f'{tech}_{name}', \
                        f"{info['description']} ({desc})"
            else:
                yield from [f'{tech}_{cg}' for cg in consumer_groups()]
        else:
            yield (tech, info.get('description', '')) if with_desc else tech


class ScenarioInfo:
    """Shorthands for information about message_ix.Scenario.

    ScenarioInfo objects have the following attributes:

    - N: 'node' set elements.
    - Y: 'year' set elements >= firstmodelyear.
    - y0: firstmodelyear, if set, else y0.
    - is_message_macro: :class:`bool`; True if a MESSAGE-MACRO scenario.

    """
    def __init__(self, scenario):
        # Computed once
        fmy = scenario.cat('year', 'firstmodelyear')
        self.y0 = int(fmy[0]) if len(fmy) else -1

        self.N = scenario.set('node').tolist()
        self.Y = list(filter(lambda y: y >= self.y0,
                             map(int, scenario.set('year'))))

        self._scenario = scenario

    @property
    def sets(self):
        return self._scenario.set_list()

    @property
    def is_message_macro(self, scenario):
        """Simple check for a MESSAGE-MACRO scenario."""
        return 'PRICE_COMMODITY' in self._scenario.par_list()


@contextmanager
def silence_log():
    """Context manager to temporarily silence log output."""
    # Get the main logger
    main_log = logging.getLogger('.'.join(__name__.split('.')[:-1]))

    try:
        main_log.setLevel(100)
        yield
    finally:
        main_log.setLevel(logging.INFO)
